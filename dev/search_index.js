var documenterSearchIndex = {"docs":
[{"location":"#CoordinateBisection","page":"Overview","title":"CoordinateBisection","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Documentation for CoordinateBisection.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"#CoordinateBisection.RCB","page":"Overview","title":"CoordinateBisection.RCB","text":"struct RCB{N, T<:Real}\n\nSplit a given set of points with optional weights into N balanced axis-aligned domains. Balanced means:\n\nIf the weights are nothing, the number of points in each domain is equalised.\nIf the weights are a Vector for each point, the sum of weights on each domain is equalised.\nIf the weights are a Matrix for each dimension of each 3D point, the sum of coordinate-wise weights is equalised.\n\nThe resulting RCB tree stores each domain's neighbours in the x, y and z members, each domain's span in the xspan, yspan and zspan members, and the spatial limits of the points used to construct it in the xlimit, ylimit and zlimit members.\n\nThe input points should have shape (3, NumPoints). When computing the neighbours, an optional \"skin\" distance may be specified, such that if any domains are less than \"skin\" apart (even if they are not physically touching), they are considered neighbours.\n\nOnce the initial RCB tree is constructed, it can be iteratively improved in optimize iterations. This is a mathematically terrible problem, so no absolute guarantees can be offered at the moment as to whether they will always improve the splitting; however, in all our tests - even with skewed points distributions - it behaves well.\n\nFields\n\nx::NTuple{N, Array{Tuple{Int64, T}, 1}} where {N, T<:Real}: Each domain's neighbours in the X/Y/Z dimension, as Tuple{DomainIndex, SplitCoordinate}\ny::NTuple{N, Array{Tuple{Int64, T}, 1}} where {N, T<:Real}\nz::NTuple{N, Array{Tuple{Int64, T}, 1}} where {N, T<:Real}\nxspan::NTuple{N, Tuple{T, T}} where {N, T<:Real}: Each domain's span in the X/Y/Z dimension, as Tuple{MinCoordinate, MaxCoordinate}\nyspan::NTuple{N, Tuple{T, T}} where {N, T<:Real}\nzspan::NTuple{N, Tuple{T, T}} where {N, T<:Real}\nxlimit::Tuple{T, T} where T<:Real: Limits of points over which the RCB was constructed, as Tuple{MinCoordinate, MaxCoordinate}\nylimit::Tuple{T, T} where T<:Real\nzlimit::Tuple{T, T} where T<:Real\n\nMethods\n\nRCB{N, T}(points, weights=nothing, skin=T(0.), optimize=2N) where {N, T <: Real}\nndims(::RCB{N, T}) where {N, T} = N\neltype(::RCB{N, T}) where {N, T} = T\n\nExamples\n\nSplit 10 points into 3 domains:\n\nusing CoordinateBisection\nusing Random\n\nRandom.seed!(123)\npoints = rand(3, 10)\n\nrcb = RCB{3, Float64}(points)\n\nYou can plot results if Makie is loaded:\n\nusing GLMakie\n\n#Â Possible rcbplot arguments:\nrcbplot(rcb)\nrcbplot(rcb, points)\nrcbplot(rcb, points, weights)\n\nInteractive plots showing optimisation iterations can be shown with GLMakie:\n\nusing GLMakie\n\ninteractive_rcbplot(points, weights)\n\n\n\n\n\n","category":"type"},{"location":"#CoordinateBisection.domain_weights-Union{Tuple{T}, Tuple{N}, Tuple{RCB{N, T}, Any}, Tuple{RCB{N, T}, Any, Any}} where {N, T}","page":"Overview","title":"CoordinateBisection.domain_weights","text":"domain_weights(\n    rcb::RCB{N, T},\n    points,\n    weights=nothing,\n) where {N, T} -> MVector{N, Tuple{T, T, T}}\n\nCompute the total points' weight in each domain of rcb.\n\n\n\n\n\n","category":"method"}]
}
